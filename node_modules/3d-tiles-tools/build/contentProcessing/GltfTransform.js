"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GltfTransform = void 0;
const draco3d_1 = __importDefault(require("draco3d"));
const meshoptimizer_1 = require("meshoptimizer");
const meshoptimizer_2 = require("meshoptimizer");
const core_1 = require("@gltf-transform/core");
const extensions_1 = require("@gltf-transform/extensions");
const EXTStructuralMetadata_1 = require("../gltfExtensions/EXTStructuralMetadata");
const EXTMeshFeatures_1 = require("../gltfExtensions/EXTMeshFeatures");
const EXTInstanceFeatures_1 = require("../gltfExtensions/EXTInstanceFeatures");
/**
 * Utilities for using glTF-Transform in the 3D Tiles tools
 *
 * @internal
 */
class GltfTransform {
    /**
     * Returns the `gltf-transform` `NodeIO` instance, preconfigured
     * for the use in the 3D Tiles Tools.
     *
     * (E.g. it will be configured to handle the all extensions that
     * are known in glTF-Transform, as well as EXT_mesh_features and
     * EXT_structural_metadata, and have draco- and meshopt
     * encoders/decoders)
     *
     * @returns - The `NodeIO` instance
     */
    static async getIO() {
        if (GltfTransform.io) {
            return GltfTransform.io;
        }
        const io = new core_1.NodeIO();
        io.registerExtensions(extensions_1.ALL_EXTENSIONS).registerDependencies({
            "draco3d.decoder": await draco3d_1.default.createDecoderModule(),
            "draco3d.encoder": await draco3d_1.default.createEncoderModule(),
            "meshopt.decoder": meshoptimizer_1.MeshoptDecoder,
            "meshopt.encoder": meshoptimizer_2.MeshoptEncoder,
        });
        // Note: The order of these calls matters. The EXTMeshFeatures and
        // EXTInstanceFeatures depend on the EXTStructuralMetadata, because
        // they may refer to PropertyTable objects via their FeatureId.
        // So the EXTStructuralMetadata has to be read first.
        io.registerExtensions([EXTStructuralMetadata_1.EXTStructuralMetadata]);
        io.registerExtensions([EXTMeshFeatures_1.EXTMeshFeatures]);
        io.registerExtensions([EXTInstanceFeatures_1.EXTInstanceFeatures]);
        GltfTransform.io = io;
        return io;
    }
    /**
     * Calls `gltf-transform` on a GLB buffer and returns the transformed
     * buffer.
     *
     * It will read the GLB data, apply the `transform` call to the
     * resulting `Document` (using the given `Transform` instances),
     * and return a GLB buffer that was crated from the transformed
     * document.
     *
     * @param transforms - The `gltf-transform` `Transform` instances
     * @returns The function
     */
    static async process(inputGlb, ...transforms) {
        const io = await GltfTransform.getIO();
        const document = await io.readBinary(inputGlb);
        await document.transform(...transforms);
        const outputGlb = await io.writeBinary(document);
        return Buffer.from(outputGlb);
    }
}
exports.GltfTransform = GltfTransform;
