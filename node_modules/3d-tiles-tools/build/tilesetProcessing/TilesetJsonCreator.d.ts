import { Tileset } from "../structure/Tileset";
/**
 * A class for creating `Tileset` JSON objects from tile content files.
 *
 * @internal
 */
export declare class TilesetJsonCreator {
    /**
     * Creates a tileset that uses the specified files as its
     * tile contents.
     *
     * Many details about the resulting tileset are intentionally
     * not specified.
     *
     * @param baseDir - The base directory against which the
     * content URIs are resolved
     * @param contentUris - The content URIs
     * @returns The tileset
     * @throws Error if content data could not be read
     */
    static createTilesetFromContents(baseDir: string, contentUris: string[]): Promise<Tileset>;
    /**
     * Creates a leaf tile with the specified tile content.
     *
     * The content data will be loaded from the specified file, given
     * as `<baseDir>/<contentUri>`. The content data type will be
     * determined.
     *
     * If the content data type is one of the supported types (which
     * are unspecified for now), then its bounding volume will be
     * computed, and used as the bounding volume of the resulting tile.
     *
     * If the content data type is not supported, then a warning
     * will be printed and `undefined` will be returned.
     *
     * @param baseDir - The base directory against which the
     * content URI is resolved
     * @param contentUri - The content URI
     * @returns The leaf tile
     * @throws Error if content data could not be read
     */
    private static createLeafTileFromContent;
    /**
     * Computes the bounding box from the given content data.
     *
     * @param contentUri - The content URI
     * @param data - The content data
     * @param externalGlbResolver - The resolver for external GLBs in I3DMs
     * @returns The bounding box, or undefined if no bounding box could
     * be computed from the given content.
     * @throws Error if the I3DM referred to a GLB that could not be
     * resolved
     */
    private static computeContentDataBoundingBox;
    /**
     * Creates a tileset with the given leaf tiles.
     *
     * This assumes that the given tiles do not have a `transform`.
     *
     * If there is only one leaf tile, then this will become
     * the root of the tileset. Otherwise, the tileset root
     * will have the given tiles as its children.
     *
     * @param leafTiles - The leaf tiles
     * @returns The tileset
     */
    private static createTilesetFromLeafTiles;
    /**
     * Creates a parent tile for the given child tiles.
     *
     * This assumes that the child tiles do not have a `transform`.
     *
     * It will compute the bounding volume box of the parent tile
     * from the bounding volume boxes of the children (using
     * `computeTilesUnionBoundingVolumeBox`), and a suitable (but unspecified)
     * geometric error for the parent tile.
     *
     * @param children - The children
     * @returns The parent tile
     */
    private static createParentTile;
    /**
     * Computes the `boundingVolume.box` that is the union of all bounding
     * volume boxes of the given tiles.
     *
     * This assumes that the child tiles do not have a `transform`.
     *
     * It also assumes that the input tile bounding volumes are actually
     * bounding boxes. Tiles that have different types of bounding
     * volumes will be ignored. If no tile has a bounding volume box,
     * then a unit cube bounding volume box will be returned.
     *
     * @param tiles - The input tiles
     * @returns The bounding volume box
     */
    private static computeTilesUnionBoundingVolumeBox;
    /**
     * Computes the union of the given boundingVolumeBoxes.
     *
     * If the given array is empty, then then a unit cube bounding
     * volume box will be returned.
     *
     * @param boundingVolumeBoxes - The bounding volume boxes
     * @returns The union volume box
     */
    private static computeUnionBoundingVolumeBox;
    /**
     * Creates a leaf tile from the given data
     *
     * @param boundingVolume - The bounding volume
     * @param geometricError - The geometric error
     * @param contentUri - The content URI
     * @returns The tile
     */
    private static createLeafTile;
    /**
     * Computes the bounding box of the given PNTS data
     *
     * @param pntsBuffer - The PNTS data buffer
     * @returns A promise to the bounding box
     */
    private static computeBoundingBoxFromPnts;
    /**
     * Computes the bounding box of the given B3DM data
     *
     * @param b3dmBuffer - The B3DM data buffer
     * @returns A promise to the bounding box
     */
    private static computeBoundingBoxFromB3dm;
    /**
     * Computes the bounding box of the given I3DM data
     *
     * @param i3dmBuffer - The I3DM data buffer
     * @param externalGlbResolver - The resolver for external GLB data from I3DMs
     * @returns A promise to the bounding box
     * @throws Error if the I3DM referred to a GLB that could not be
     * resolved
     */
    private static computeBoundingBoxFromI3dm;
    /**
     * Computes the bounding box of the given CMPT data
     *
     * @param cmptBuffer - The CMPT data buffer
     * @returns A promise to the bounding box
     */
    private static computeBoundingBoxFromCmpt;
    /**
     * Transforms the given 3D point with the given 4x4 matrix, writes
     * the result into the given target, and returns it. If no target
     * is given, then a new point will be created and returned.
     *
     * @param matrix - The 4x4 matrix
     * @param point - The 3D point
     * @param target - The target
     * @returns The result
     */
    private static transformPoint3D;
    /**
     * Computes the bounding box of the given glTF asset.
     *
     * This will compute the bounding box of the default scene
     * (or the first scene of the asset). If there is no scene,
     * then a warning will be printed, and a unit cube bounding
     * box will be returned.
     *
     * @param glbBuffer - The buffer containing GLB data
     * @returns A promise to the bounding box
     */
    private static computeBoundingBoxFromGlb;
}
//# sourceMappingURL=TilesetJsonCreator.d.ts.map