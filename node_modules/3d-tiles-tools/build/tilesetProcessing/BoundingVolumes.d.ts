/**
 * @internal
 */
export type Point3D = [number, number, number];
/**
 * @internal
 */
export type BoundingBox3D = {
    min: Point3D;
    max: Point3D;
};
/**
 * Utility methods for bounding volume computations.
 *
 * This class is only supposed to be used in the TilesetJsonCreator.
 *
 * To reduce ambiguities, the term "bounding box" refers to actual
 * `BoundingBox3D` instances. The term "bounding volume box" refers
 * to the 12-element number arrays that are the `boundingVolume.box`.
 *
 * @internal
 */
export declare class BoundingVolumes {
    /**
     * Creates a bounding box for the unit cube
     *
     * @returns The bounding box
     */
    static createUnitCubeBoundingBox(): BoundingBox3D;
    /**
     * Creates a bounding volume box for the unit cube
     *
     * @returns The bounding volume box
     */
    static createUnitCubeBoundingVolumeBox(): number[];
    /**
     * Creates a boundingVolume.box from a given bounding box
     *
     * @param boundingBox - The bounding box
     * @returns The `boundingVolume.box`
     */
    static createBoundingVolumeBoxFromBoundingBox(boundingBox: BoundingBox3D): number[];
    /**
     * Computes an array containing the 8 corners of the given
     * bounding box.
     *
     * @param boundingBox - The bounding box
     * @returns The corners
     */
    static computeBoundingBoxCorners(boundingBox: BoundingBox3D): Point3D[];
    /**
     * Creates a bounding box for a tileset- or tile bounding volume.
     *
     * This is the center- and half-axis representation of the
     * `boundingVolume.box` that is described at
     * https://github.com/CesiumGS/3d-tiles/tree/main/specification#box,
     * computed from the minimum- and maximum point of a box.
     *
     * @param minX - The minimum x
     * @param minY - The minimum y
     * @param minZ - The minimum z
     * @param maxX - The maximum x
     * @param maxY - The maximum y
     * @param maxZ - The maximum z
     * @returns The `boundingVolume.box`
     */
    private static createBoundingVolumeBox;
    /**
     * Creates a boundingVolume.box from a given glTF bounding box.
     *
     * This will take into account the fact that a glTF asset with
     * the given bounding box will be transformed with the
     * y-up-to-z-up transform.
     *
     * @param boundingBox - The bounding box
     * @returns The `boundingVolume.box`
     */
    static createBoundingVolumeBoxFromGltfBoundingBox(boundingBox: BoundingBox3D): number[];
    /**
     * Create the BoundingBox3D for the given boundingVolume.box
     *
     * @param boundingVolumeBox - The bounding volume box
     * @returns The bounding box
     */
    static createBoundingBoxForBoundingVolumeBox(boundingVolumeBox: number[]): BoundingBox3D;
    /**
     * Translate the given bounding box by the given amount
     *
     * @param boundingBox - The bounding box
     * @param translation - The translation
     * @returns The translated bounding box
     */
    static translateBoundingBox(boundingBox: BoundingBox3D, translation: Point3D): {
        min: Point3D;
        max: Point3D;
    };
    /**
     * Computes the component-wise sum of the given points.
     *
     * The result will be put into the given result point and
     * returned. If the result point is not given, a new point
     * will be returned.
     *
     * @param p0 - The first point
     * @param p1 - The second point
     * @param result - The point that stores the result
     * @returns The result
     */
    private static add;
    /**
     * Computes the component-wise minimum of the given points.
     *
     * The result will be put into the given result point and
     * returned. If the result point is not given, a new point
     * will be returned.
     *
     * @param p0 - The first point
     * @param p1 - The second point
     * @param result - The point that stores the result
     * @returns The result
     */
    static min(p0: Point3D, p1: Point3D, result?: Point3D): Point3D;
    /**
     * Computes the component-wise maximum of the given points.
     *
     * The result will be put into the given result point and
     * returned. If the result point is not given, a new point
     * will be returned.
     *
     * @param p0 - The first point
     * @param p1 - The second point
     * @param result - The point that stores the result
     * @returns The result
     */
    static max(p0: Point3D, p1: Point3D, result?: Point3D): Point3D;
    /**
     * Computes the union of the given bounding boxes
     *
     * @param bb0 - The first bounding box
     * @param bb1 - The second bounding box
     * @returns The union
     */
    static computeBoundingBoxUnion(bb0: BoundingBox3D, bb1: BoundingBox3D): BoundingBox3D;
}
//# sourceMappingURL=BoundingVolumes.d.ts.map